<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<title>Random Japanese Sentence - Lite</title>


	<style>
		body {
			font-size: clamp(16px, 1.5vw + 10px, 50px);
			/* background: black; */
			background: rgb(2, 0, 36);
			background: radial-gradient(circle, rgb(0, 0, 0) 0%, rgb(2, 2, 68) 100%);
			color: white;
			padding: clamp(18px, 1vw, 22px);

			font-family: 'Baskerville', 'YuMincho +36p Kana', 'Hiragino Mincho ProN W6', serif;
		}

		h1 {
			font-weight: 900;
		}


		button {
			border-radius: 10px;
			border: 1px solid white;
			padding: 0.5em 1em;
			font-size: 0.5em;
			/* font-weight: 500; */
			font-family: inherit;
			background-color: #000000;
			color: white;
			cursor: pointer;
			/* transition: border-color 0.25s; */
		}

		button:hover {
			border-color: #646cff;
		}

		button:focus,
		button:focus-visible {
			outline: 4px auto -webkit-focus-ring-color;
		}
	</style>
</head>

<body>
	<div
		style="display:grid;place-items:center;align-content: center; min-height: -webkit-fill-available;min-height: 100vh;">
		<h1 id="japanese" style="text-align: center; margin: 0 0 0.2em;">Loading Sentence...</h1>
		<span id="translation" style="text-align: center; margin: 0 0 0.7em;"></span>

		<button id="speakButton">Speak Japanese Sentence</button>
		<button id="speakTest">Speak test Sentence</button>
	</div>


	<script>
		let _speechSynth
		let _voices
		const _cache = {}

		/**
		 * retries until there have been voices loaded. No stopper flag included in this example. 
		 * Note that this function assumes, that there are voices installed on the host system.
		 */

		function loadVoicesWhenAvailable(onComplete = () => { }) {
			_speechSynth = window.speechSynthesis
			const voices = _speechSynth.getVoices()

			if (voices.length !== 0) {
				_voices = voices
				onComplete()
			} else {
				return setTimeout(function () { loadVoicesWhenAvailable(onComplete) }, 100)
			}
		}

		/**
		 * Returns the first found voice for a given language code.
		 */

		function getVoices(locale) {
			if (!_speechSynth) {
				throw new Error('Browser does not support speech synthesis')
			}
			if (_cache[locale]) return _cache[locale]

			_cache[locale] = _voices.filter(voice => voice.lang === locale)
			return _cache[locale]
		}

		/**
		 * Speak a certain text 
		 * @param locale the locale this voice requires
		 * @param text the text to speak
		 * @param onEnd callback if tts is finished
		 */

		function playByText(locale, text, onEnd) {
			const voices = getVoices(locale)

			// TODO load preference here, e.g. male / female etc.
			// TODO but for now we just use the first occurrence
			const utterance = new window.SpeechSynthesisUtterance()
			utterance.voice = voices[0]
			utterance.pitch = 1
			utterance.rate = 1
			utterance.voiceURI = 'native'
			utterance.volume = 1
			utterance.rate = 1
			utterance.pitch = 0.8
			utterance.text = text
			utterance.lang = locale

			if (onEnd) {
				utterance.onend = onEnd
			}

			_speechSynth.cancel() // cancel current speak, if any is running
			_speechSynth.speak(utterance)
		}

		// on document ready
		loadVoicesWhenAvailable(function () {
			console.log("loaded")
		})

		// function speak() {
		// 	setTimeout(() => , 300)

		// }

		speakTest.addEventListener("click", () => {
			playByText("ja-JP", "Hello, world");
		})

		let voice = window.speechSynthesis
			.getVoices()
			.filter((v) => v.lang.startsWith("ja"))[0];

		// let japaneseText;
		fetch("https://tatoeba.elnu.com/?from=jpn&orphans=no&sort=random&to=eng&trans_filter=limit&trans_to=eng&unapproved=no&limit=1&current=1").then(r => r.json())
			.then(response => {
				console.log(response);
				let japaneseText = response.results[0].text;
				let japaneseRuby = response.results[0].transcriptions[0].html;

				// filter the Japanese Text for full width period, and replace it with a half width period
				japaneseRuby = japaneseRuby.replace(/。/g, "｡").replace(/？/g, "?").replace(/！/g, "!");

				japanese.innerHTML = japaneseRuby;
				if (response.results[0].translations[0]) {
					translation.innerHTML = response.results[0].translations[0][0].text;
				}
				else if (response.results[0].translations[1]) {
					translation.innerHTML = response.results[0].translations[1][0].text;
				}
				else {
					translation.innerHTML = "No translation available";
				}

				speakButton.addEventListener("click", () => {
					if (japaneseText) {
						let utterance = new SpeechSynthesisUtterance(japaneseText);
						utterance.lang = "ja";
						utterance.rate = 0.8;
						utterance.voice = voice;
						speechSynthesis.speak(utterance);
					}
				})
			})

		// function speakSentence(sentence) {
		// 	let utterance = new SpeechSynthesisUtterance(sentence);
		// 	utterance.lang = "ja-JP";
		// 	utterance.rate = 0.8;
		// 	speechSynthesis.speak(utterance);
		// }

		// // Chrome loads voices asynchronously.
		// window.speechSynthesis.onvoiceschanged = function (e) {
		// 	speakButton.addEventListener("click", () => {
		// 		if (japaneseText) {
		// 			speakSentence(japaneseText);
		// 		}
		// 	})
		// };

	</script>
</body>

</html>